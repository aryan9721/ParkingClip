'use strict';

process.env.BABEL_ENV = 'production';
process.env.NODE_ENV = 'production';

const path = require('path');
const chalk = require('react-dev-utils/chalk');
const fs = require('fs-extra');
const webpack = require('webpack');
const configFactory = require('../config/webpack.config');
const formatWebpackMessages = require('react-dev-utils/formatWebpackMessages');
const FileSizeReporter = require('react-dev-utils/FileSizeReporter');
const filesize = require('filesize');
const stripAnsi = require('strip-ansi');
const gzipSize = require('gzip-size').sync;

const log = require('../utils/logger').logger;

const measureFileSizesBeforeBuild = FileSizeReporter.measureFileSizesBeforeBuild;

// These sizes are pretty large. We'll warn for bundles exceeding them.
const WARN_AFTER_BUNDLE_GZIP_SIZE = 512 * 1024;
const WARN_AFTER_CHUNK_GZIP_SIZE = 1024 * 1024;

async function copyPublicFolder(cPaths) {
	return fs.copy(cPaths.appPublic, cPaths.appBuild, {
		dereference: true,
		filter: (file) => file !== cPaths.appHtml
	});
}

async function copyClientPackage(packageJsonFile, cPaths) {
	return fs.copyFile(packageJsonFile, path.join(cPaths.appBuild, path.basename(packageJsonFile)));
}

async function build(config) {
	log('Creating an optimized production build...');
	// Generate configuration
	const compiler = webpack(config);
	return new Promise((resolve, reject) => {
		compiler.run((err, stats) => {
			let messages;
			if (err) {
				if (!err.message) {
					return reject(err);
				}

				let errMessage = err.message;

				// Add additional information for postcss errors
				if (Object.prototype.hasOwnProperty.call(err, 'postcssNode')) {
					errMessage +=
						'\nCompileError: Begins at CSS selector ' + err.postcssNode.selector;
				}

				messages = formatWebpackMessages({
					errors: [errMessage],
					warnings: []
				});
			} else {
				const rawMessage = stats.toJson({ all: false, warnings: true, errors: true });
				messages = formatWebpackMessages({
					errors: rawMessage.errors.map((e) => e.message),
					warnings: rawMessage.warnings.map((e) => e.message)
				});
			}
			if (messages.errors.length) {
				// Only keep the first error. Others are often indicative
				// of the same problem, but confuse the reader with noise.
				if (messages.errors.length > 1) {
					messages.errors.length = 1;
				}
				return reject(new Error(messages.errors.join('\n\n')));
			}
			if (
				process.env.CI &&
				(typeof process.env.CI !== 'string' || process.env.CI.toLowerCase() !== 'false') &&
				messages.warnings.length
			) {
				log(
					chalk.yellow(
						'\nTreating warnings as errors because process.env.CI = true.\n' +
							'Most CI servers set it automatically.\n'
					)
				);
				return reject(new Error(messages.warnings.join('\n\n')));
			}

			const resolveArgs = {
				stats,
				warnings: messages.warnings
			};

			return resolve(resolveArgs);
		});
	});
}

function printBuildError(err) {
	const message = err != null && err.message;
	const stack = err != null && err.stack;

	// Add more helpful message for Terser error
	if (stack && typeof message === 'string' && message.indexOf('from Terser') !== -1) {
		try {
			const matched = /(.+)\[(.+):(.+),(.+)\]\[.+\]/.exec(stack);
			if (!matched) {
				throw new Error('Using errors for control flow is bad.');
			}
			const problemPath = matched[2];
			const line = matched[3];
			const column = matched[4];
			log(
				'Failed to minify the code from this file: \n\n',
				chalk.yellow(`\t${problemPath}:${line}${column !== '0' ? ':' + column : ''}`),
				'\n'
			);
		} catch (ignored) {
			log('Failed to minify the bundle.', err);
		}
		log('Read more here: https://cra.link/failed-to-minify');
	} else {
		log((message || err) + '\n');
	}
	log(' ');
}

function canReadAsset(asset) {
	return (
		/\.(js|css)$/.test(asset) &&
		!/service-worker\.js/.test(asset) &&
		!/precache-manifest\.[0-9a-f]+\.js/.test(asset)
	);
}

function removeFileNameHash(buildFolder, fileName) {
	return fileName
		.replace(buildFolder, '')
		.replace(/\\/g, '/')
		.replace(/\/?(.*)(\.[0-9a-f]+)(\.chunk)?(\.js|\.css)/, (match, p1, p2, p3, p4) => p1 + p4);
}

// Input: 1024, 2048
// Output: "(+1 KB)"
function getDifferenceLabel(currentSize, previousSize) {
	var FIFTY_KILOBYTES = 1024 * 50;
	var difference = currentSize - previousSize;
	var fileSize = !Number.isNaN(difference) ? filesize(difference) : 0;
	if (difference >= FIFTY_KILOBYTES) {
		return chalk.red('+' + fileSize);
	} else if (difference < FIFTY_KILOBYTES && difference > 0) {
		return chalk.yellow('+' + fileSize);
	} else if (difference < 0) {
		return chalk.green(fileSize);
	} else {
		return '';
	}
}

// Prints a detailed summary of build files.
function printFileSizesAfterBuild(
	webpackStats,
	previousSizeMap,
	buildFolder,
	maxBundleGzipSize,
	maxChunkGzipSize
) {
	var root = previousSizeMap.root;
	var sizes = previousSizeMap.sizes;
	var assets = (webpackStats.stats || [webpackStats])
		.map((stats) =>
			stats
				.toJson({ all: false, assets: true })
				.assets.filter((asset) => canReadAsset(asset.name))
				.map((asset) => {
					var fileContents = fs.readFileSync(path.join(root, asset.name));
					var size = gzipSize(fileContents);
					var previousSize = sizes[removeFileNameHash(root, asset.name)];
					var difference = getDifferenceLabel(size, previousSize);
					return {
						folder: path.join(path.basename(buildFolder), path.dirname(asset.name)),
						name: path.basename(asset.name),
						size: size,
						sizeLabel: filesize(size) + (difference ? ' (' + difference + ')' : '')
					};
				})
		)
		.reduce((single, all) => all.concat(single), []);
	assets.sort((a, b) => b.size - a.size);
	var longestSizeLabelLength = Math.max.apply(
		null,
		assets.map((a) => stripAnsi(a.sizeLabel).length)
	);
	var suggestBundleSplitting = false;
	assets.forEach((asset) => {
		var sizeLabel = asset.sizeLabel;
		var sizeLength = stripAnsi(sizeLabel).length;
		if (sizeLength < longestSizeLabelLength) {
			var rightPadding = ' '.repeat(longestSizeLabelLength - sizeLength);
			sizeLabel += rightPadding;
		}
		var isMainBundle = asset.name.indexOf('main.') === 0;
		var maxRecommendedSize = isMainBundle ? maxBundleGzipSize : maxChunkGzipSize;
		var isLarge = maxRecommendedSize && asset.size > maxRecommendedSize;
		if (isLarge && path.extname(asset.name) === '.js') {
			suggestBundleSplitting = true;
		}
		log(
			'  ' +
				(isLarge ? chalk.yellow(sizeLabel) : sizeLabel) +
				'  ' +
				chalk.dim(asset.folder + path.sep) +
				chalk.cyan(asset.name)
		);
	});
	if (suggestBundleSplitting) {
		log(' ');
		log(chalk.yellow('The bundle size is significantly larger than recommended.'));
		log(chalk.yellow('Consider reducing it with code splitting: https://goo.gl/9VhYWB'));
		log(chalk.yellow('You can also analyze the project dependencies: https://goo.gl/LeUzfb'));
	}
}

module.exports = async (userDir, packageJsonFile) => {
	const paths = require('../config/paths')(userDir);
	const previousFileSizes = await measureFileSizesBeforeBuild(paths.appBuild);
	await fs.emptyDir(paths.appBuild);
	await copyPublicFolder(paths);
	await copyClientPackage(packageJsonFile, paths);
	// Start the webpack build
	try {
		process.chdir(userDir);
		const config = configFactory('production', userDir);
		const { stats, warnings } = await build(config);
		if (warnings.length) {
			log(chalk.yellow('Compiled with warnings.\n'));
			log(warnings.join('\n\n'));
			log(
				'\nSearch for the ' +
					chalk.underline(chalk.yellow('keywords')) +
					' to learn more about each warning.'
			);
			log(
				'To ignore, add ' +
					chalk.cyan('// eslint-disable-next-line') +
					' to the line before.\n'
			);
		} else {
			log(chalk.green('Compiled successfully.\n'));
		}

		log('File sizes after gzip:\n');
		printFileSizesAfterBuild(
			stats,
			previousFileSizes,
			paths.appBuild,
			WARN_AFTER_BUNDLE_GZIP_SIZE,
			WARN_AFTER_CHUNK_GZIP_SIZE
		);
		log(' ');
	} catch (err) {
		const tscCompileOnError = process.env.TSC_COMPILE_ON_ERROR === 'true';
		if (tscCompileOnError) {
			log(
				chalk.yellow(
					'Compiled with the following type errors (you may want to check these before deploying your app):\n'
				)
			);
			printBuildError(err);
		} else {
			log(chalk.red('Failed to compile.\n'));
			printBuildError(err);
			throw new Error('Compilation failed');
		}
	}
	return paths.appBuild;
};
